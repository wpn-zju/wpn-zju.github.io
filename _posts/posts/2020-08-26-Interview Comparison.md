---
layout: post
title: "内卷的社会、内卷的面试"
subtitle:
author: "Peinan"
header-style: text
category: posts
tags:
  - Project
---

未完稿

今年夏天，我投递了中美两国近10家大型互联网公司的暑期开发实习岗位，包括腾讯、阿里、字节、亚马逊、谷歌、微软等。

<p>&nbsp</p>

在参加这些Top-Tech Company面试的过程中，让我感触最深的是中美互联网企业面试着重点和对应聘者能力要求的差异。

<p>&nbsp</p>

有较多国内公司面试经历的应届生会发现，国内面试的题目，如果不考虑特定方向有关的题目，如前后端具体的框架使用，剩下的考察无非就是项目经验和本科学过的几大件，
+ 数据结构与算法
+ 网络
+ 操作系统
+ 编程语言
+ 部分后端岗位可能数据库必考，我暂时没遇到

相比之下国外大厂的面试（至少是实习生面试）思路要清晰的多，项目经验 + 算法题（主要考察）+ 少量基础知识 + Behavioral Questions。

根据我的面试经验，我想通过我遇到的几个例子对比一下中美企业面试在具体知识点上的考察差异。
+ TCP拥塞控制的经典图片，每个国内应聘者必背之一
  + 换种问法 
+ HTTPS非对称加密过程图
  + 换种问法
+ AVL树
  + 换种问法

<p>&nbsp</p>

另外前几天一个好朋友分享的面试题也引起了我的关注，原题是问下面一段代码在32位环境下会产生什么效果？

```cpp
class A {
public:
    virtual void print() {
        printf("Hello World!");
    }
};

class B : public A {
public:
    int i;
};

int main() {
    B b;
    memset(&b.i - 1, 0, 8);
    b.print();
    return 0;
}
```

这是一道典型考察类内存布局和值类型、引用类型差异的题。可惜不少同学可能想到了[类内存布局的特点](https://wpn-zju.github.io/notes/2020/04/03/Cpp-Class-Memory/)，虚指针地址小于类成员，在这里回答了Runtime Error，却没有想到还有静态联编的坑，此处是能输出Hello World!的。即使在运行时我们抹除了虚指针，由于静态联编的存在，这段代码在编译完之后b.print();该句执行的函数入口就已经写死了，根本用不着虚指针和虚表出场。

如果要抹去虚指针使得Runtime Error需要将代码改为

```cpp
class A {
public:
    virtual void print() {
        printf("Hello World!");
    }
};

class B : public A {
public:
    int i;
};

int main() {
    B* b = new B();
    memset(&b->i - 1, 0, 8);
    b->print();
    delete b; // Not necessary
    return 0;
}
```

事后我总结时的理解是，对于以值类型直接构建和表示的类对象，编译期唯一能确定它的真实类型，并绑定到相应的成员函数地址上，我们可以绕过虚指针和虚表来提高运行效率(Static Binding)。而对于指针形式构建的类型，指针是多态调用的关键，也容易发生强制转换，因此函数入口地址的查询真正被下放到了runtime (Dynamic Binding)，此时对虚指针的清零操作才会导致Runtime Error。这些实现细节其实和编译器也有很大的关系，直接作为面试题有些不妥。为何不直接拆成指针和值对象的差异理解考察和类内存模型的考察两道题呢？

<p>&nbsp</p>

上面这个例子可以算是另外一类更典型的国内面试题，强行给出一个完全脱离生产环境，“写出来会被同事拖出去打一顿”的代码问你运行结果。类似的还有我曾经遇到的面试第一题

```cpp
int p = 5;
int i = (--p)++;
```

问p和i的值，正确答案是p = 4和i = 4。

作为一个系统性学过Cpp的人来说，preInc和postInc的差异和它们的重载写法显然是必须要会的，我也早就形成了循环用++i代替i++的癖好（实际上经过编译器优化并没有差别）。可是谁又能保证你在比较迷糊的情况下（由于时差，当时是早上7点的店面）不会答错这样绕弯路、非正常写法的题目呢？事实是那天我确实第一题遇到这玩意就翻车了，面完后郁闷了许久。

学习如何做是对的、可行的，而不是如何做是错的并用排除法去得到答案。后者是应试教育考题的一大特点。

<p>&nbsp</p>

国内的问题很容易概括成考察过细且单一，也正因如此，在和同学讨论如何高效应付国内企业的面试时，我总是扔出下面一个模板：
1. 确定你要投递的岗位、方向。
2. 打开牛客网，输入该岗位名称 + 面经进行搜索。
3. 收集20篇左右同一岗位的面经。将所有题目整理到Word文档中。
4. 一般来说每篇面经有10道面试题，排除重复，此时你大约手上有100道面试题。
5. (Optional)按照类别如网络、OS、数据结构与算法将题目进行细分。
6. 找出这些题目的答案，热心的前辈会把答案直接放进面经里，但有时你也需要自己动手。
7. 往死里背。（当然前提你得曾经学过相关知识，如网络、OS、数据结构与算法等）
   
相比之下，在参加美国企业面试时，虽然面经也具有很大的参考价值，但根本不会像国内那样你不背就根本别想过。通常我们会选择Leetcode 300题作为算法知识储备，Behavioral Question部分会参考面经，但也仅限于题目本身，毕竟这部分问题本就没有标准答案。


<p>&nbsp</p>

对知识点考察过细，难免出现面试造火箭，入职拧螺丝的情况。而过细、开放性差的同时题目又过于单一，便会出现全民背板的应试现象。

同时，这个问题的关键在于我们是否真的需要对这些知识掌握得如此细致，信手拈来？

毫无疑问，作为一名准备进入这些互联网大企业的应届生，你当然应当掌握所有几大件包含的基础知识，它们是日常工作的效率保证，给你提供的是远比工具使用重要的系统性的理解。然而这并不代表考察的方式应当是记忆和复述。讲到机械记忆式学习，很容易想到我们的高考。前几天国内刚结束高考时，我也颇有兴致地找来了浙江的卷子看了一看，尝试做了里面几个题目。结果是除了英语由于我现在在美国生活的原因能保持以前的成绩以外，其它几门课根本没法达到高三时的熟练度和成绩，曾经140+的数学，现在回过去看，怕是三位数都上不了。有人说应试教育的好处是训练了学习能力、竞争意识等，这一点也没错，高中三年对我的帮助也非常大，特别是锻炼了人的抗逆性。但与此同时，对于考察内容本身，应试教育的效果是非常差的，学过的知识又用不到之后的学习、工作中，谁还能记得住呢？同理对于一些面试题，也许我们通过突击确实能记住标准答案，但是一周后、一个月后呢？又真的有新入职的应届生会在他们头两年的开发中同时涉及进程间通信、多线程调度、TCP拥塞控制、平衡二叉查找树的插入、虚拟内存管理和C++类内存模型吗，我想主流应该还是基础业务逻辑的完善和CRUD吧。

话说回来毕竟考大学只有一次，而相对来说跳槽找工作面试的频率要高得多，每到招聘季就开始一波又一波的刷题背书，是对时间的严重浪费。（进入大学的时候，我曾经以为高考会是我最后一次接受应试教育的挑战，直接导致我本科的翻车，现在回想起来真是图森破。）


<p>&nbsp</p>

在我们所处的互联网时代，如何合理、高效的利用互联网给我们带来的巨量的、唾手可得的资源是至关重要的。学习能力远比记忆知识本身来得重要。也许在没有提前准备的情况下，我们不能流畅的复述TLS的非对称加密完整流程，但我们却能通过原有的知识记忆配合搜索引擎和网络资源在15分钟内完成快速回顾和应用，这样做大幅度提高了时间的利用率。很多开发者抱怨IT技术迭代速度快，学习成本过高，实际上很多时候利用好某一个新框架、新技术，只需按照文档操作即可，并不需要想学习高中课本一样深入和重记忆。但话说回来，学新的技术、框架是为了通过面试，面试出的问题过细，又怎能不全盘学习呢？中国的优秀人才太多，恶竞现象严重，作为面试官我无论出多难总有人能答出来，那我何乐而不为呢，至于interviewee的准备成本和时间花费以及这些题真正对能力筛选的符合程度，who cares？

<p>&nbsp</p>

Learn on demand!

<p>&nbsp</p>

对于刚完成高考的准大一生们，也许会觉得自己已经完成了应试教育的磨练，顺利通关。事实上，应试教育的内卷人生才刚刚拉开帷幕。在中国生活，有太多的残酷竞争，不是为了学习知识、提升能力，而纯粹只是为了证明自己比别人更好更强。当人生的主旋律从实现自我价值变成了永无止尽地证明自己的时候，当我们的时间一次又一次地大量花费在学了忘、忘了学地轮回中时，还有多少人能够不忘初心呢？

尽管如此，永远保持积极的心态，为了真正的目标理想去学习和探索，而不是为了考证而考证，为了考研而考研，为了找到工作而去找工作，我相信机会终会眷顾有想法、有决心、有行动的努力拼搏的人。

<p>&nbsp</p>

（参加了一次完全没准备的国内大厂面试后有感，水平有限请见谅。）

---
